##3 TODO
# 1 insert col
## rowsums
## finir tvar.gen, initial values, etc
## tvar.sim
## tvar.boot


#'Simulation and bootstrap of Threshold Autoregressive model
#'
#'Simulate or bootstrap a Threshold VAR
#'
#'This function offers the possibility to generate series following a TAR from
#'two approaches: bootstrap or simulation. When the data is given, one can use
#'a simple residual bootstrap or simulate a series from the parameter matrix
#'and with normal distributed residuals (with variance pre-specified). The
#'choice "check" is just there to check the function: one should obtain the
#'same values as the given values. Please report if different.  When the
#'parameter matrix is given, there is only the possibility to simulate series.
#'The starting values (of length equal to the number of lags) can be given. The
#'user should take care for the choice of the starting values and parameters
#'values, since it is not sure that the simulated values will cross the
#'threshold even once.
#'
#'@param data univariate time series
#'@param B vector of coefficients to simulate
#'@param setarObject Object of class linear or setar to be bootstrapped
#'@param n Number of observations to create when type="simul"
#'@param Thresh The threshold value(s). Vector of length nthresh
#'@param nthresh number of threshold (see details)
#'@param lag Number of lags to include in each regime
#'@param type Whether a bootstrap or simulation is to employ. See details
#'@param trend If a trend should be included in the model
#'@param thDelay 'time delay' for the threshold variable (as multiple of
#'embedding time delay d).
#'@param starting Starting values when a simulation with given parameter matrix
#'is made
#'@param rand.gen optional: a function to generate the innovations.
#'@param innov an optional times series of innovations.  If not provided,
#'\code{rand.gen} is used.
#'@param \dots additional arguments for \code{rand.gen}.  Most usefully, the
#'standard deviation of the innovations generated by \code{rnorm} can be
#'specified by \code{sd}.
#'@return a list with the simulated/bootstraped data and the parameter matrix
#'used.
#'@author Matthieu Stigler
#'@seealso \code{\link{SETAR}} to estimate a SETAR, \code{\link{arima.sim}} to
#'simulate an ARMA.
#'@keywords ts
#'@export
#'@examples
#'
#'##Simulation of a TAR with 1 threshold
#' TvarMat <- c(2.9,-0.4,-0.1,-1.5, 0.2,0.3)
#'sim<-setar.sim(B=TvarMat,lag=2, type="simul", nthresh=1, Thresh=2, starting=c(2.8,2.2))$serie
#'mean(ifelse(sim>2,1,0))	#approximation of values over the threshold
#'
#'#check the result
#'selectSETAR(sim, m=2)
#'
#'##Bootstrap a TAR with two threshold (three regimes)
#'sun<-(sqrt(sunspot.year+1)-1)*2
#'setar.sim(data=sun,nthresh=2,n=500, type="boot", Thresh=c(6,9))$serie
#'
#'##Check the bootstrap
#'cbind(setar.sim(data=sun,nthresh=2,n=500, type="check", Thresh=c(6,9))$serie,sun)
#'
setar.gen <- function(B, n=200, lag=1, include=c("const", "none"), 
                      nthresh=0, thDelay=0, Thresh, 
                      trendStart=1, 
                      starting=NULL,  innov, 
                      show.parMat = FALSE, ...){

## Check arguments
  if(!nthresh%in%c(0,1,2))  stop("arg nthresh should be either 0,1 or 2")
  include <- match.arg(include)
  esp <- switch(include, const=lag+1, none=lag)
  ndig <- 10

## check specification of B
  if(esp*(nthresh+1)!=length(B))
    stop("Matrix B badly specified")
  if(!is.null(starting) && length(starting)!=lag)
      stop("Bad specification of starting values. Should have as many values as the number of lags")
  
## y vec, trend vec
  y <- vector("numeric", length=n+lag)
  if(!is.null(starting)) y[seq_len(lag)] <- starting  
  trend <- c(rep(0, lag), trendStart+(0:(n-1)))  ### n-1 a starts from zero
  
## Extend B
  Bfull <<- matrix(rep(0, (lag+2)*(nthresh+1)), nrow = 1)
  colnames(Bfull) <- name_coefs(lags = lag, nthresh=nthresh, incNames = c("const", "trend"))
  add <- switch(include, "const"="const", "trend"="trend", "none"=NULL, "both" = c("const", "trend"))
  names(B) <- name_coefs(lags = lag, nthresh=nthresh, incNames = add)
  Bfull[colnames(Bfull) %in% names(B)] <-  B
  if(show.parMat) print(Bfull)
  # npar <- esp
  
  npar_reg <- lag+2
  if(nthresh==1){
    BDown <- Bfull[seq_len(npar_reg)]
    BUp   <- Bfull[-seq_len(npar_reg)]
  } else if(nthresh==2){
    BDown <- Bfull[seq_len(npar_reg)]
    BMiddle <- Bfull[seq_len(npar_reg)+npar_reg]
    BUp <- Bfull[seq_len(npar_reg)+2*npar_reg]
  }



### MAIN loop
  
  thDelay <- thDelay+1

#initial values
  Yb <- vector("numeric", length=length(y))		#Delta Y term
  Yb[1:lag] <- y[1:lag]

  z2 <- vector("numeric", length=length(y))
  z2[1:lag] <- y[1:lag]
  resb <- c(rep(0,lag), innov)	

  if(nthresh==0){
    for(i in (lag+1):length(y)){
      y[i] <- sum(Bfull[1], # intercept
                  Bfull[2]*trend[i], #trend
                  Bfull[-c(1,2)] * y[i-c(1:lag)], # lags
                  resb[i]) #residuals
    }
  } else if(nthresh==1){
    for(i in (lag+1):length(y)){
      if(round(z2[i-thDelay], ndig) <= Thresh) 
        y[i] <- sum(BDown[1], BDown[2]*trend[i], BDown[-c(1,2)] * y[i-c(1:lag)], resb[i])
      else 
        y[i] <- sum(BUp[1], BUp[2]*trend[i], BUp[-c(1,2)] * y[i-c(1:lag)], resb[i])
      z2[i] <- y[i]
    }
  } else if(nthresh==2){
    for(i in (lag+1):length(y)){
      if(round(z2[i-thDelay],ndig)<=Thresh[1]) {
        y[i] <- sum(BDown[1], BDown[-1] * y[i-c(1:lag)], resb[i])
      } else if(round(z2[i-thDelay], ndig)>Thresh[2]) {
        y[i] <- sum(BUp[1], BUp[-1] * y[i-c(1:lag)], resb[i])
      } else{ 
        y[i] <- sum(BMiddle[1], BMiddle[-1] * y[i-c(1:lag)], resb[i])
      z2[i]<-y[i]
      }
    }
  }


  list(B=B, serie=round(y, ndig))
}

### 
setar.boot <- function(setarObject, boot.scheme=c("resample", "wild1", "wild2", "check"),
                       seed = NULL, ...){

    mod <- setarObject$model.specific
    nthresh <- mod$nthresh
    
    B <- coef(setarObject)
    y_orig <- setarObject$str$x
    T_full <- length(y_orig)
    k <- setarObject$k
    lags <- setarObject$str$m
    t <-  T_full- lags
    include <- setarObject$include
    
    if(inherits(setarObject,"linear")){
      B <- coef(setarObject)
      Thresh <-  NA # irelevant
    }
    
    if(inherits(setarObject,"setar")){
      coefs_mod <- coef(setarObject)
      TotNpar <- length(coefs_mod)-nthresh
      B <- coefs_mod[seq_len(TotNpar)]
      Thresh <- getTh(coefs_mod)
      
      incNames <- mod$incNames
      thDelay <- mod$thDelay
      if(incNames%in%c("none", "trend"))
        stop("Arg include = none or trend currently not implemented")
      if(incNames=="trend")
        trend<-TRUE
      
      # BUp<-B[grep("H", names(B))]
      # BDown<-B[grep("L", names(B))]
      # if(mod$nthresh==2)
      #   BMiddle<-B[grep("M", names(B))]
      # if(mod$restriction=="OuterSymAll"){
      #   BUp<-B[grep("H", names(B))]
      #   BMiddle<-B[grep("L", names(B))]
      #   BDown<-BUp
      #   nthresh<-2
      #   Thresh<-c(-Thresh, Thresh)
      # }
    }
    
    ## retrieve starting values
    starts <- y_orig[1:lags]
    
    ## residuals, boot them
    resids <- residuals(setarObject)[-c(1:lags)]
    if(!is.null(seed)) set.seed(seed) 
    innov <- resamp(resids, boot.scheme = boot.scheme, seed=seed)
    
    ##
    setar.gen(B = B, lag = lags,
              nthresh = nthresh, Thresh = Thresh,
              include= include, 
              starting = starts,  
              innov = innov, n = t, ...)
}

setar.sim <- function(B, n=200, lag=1, include = c("const", "trend","none", "both"),  
                      nthresh=1, Thresh,
                      starting=NULL, innov=rnorm(n)){
  
  include <- match.arg(include)
  setar.gen(B=B, n=n, lag=lag, include = include,  
            nthresh = nthresh, Thresh = Thresh,
            starting=starting, innov=innov)
}




if(FALSE){
  library(tsDyn)
  # environment(setar.gen) <- environment(star)
  # environment(setar.boot) <- environment(star)
  
  ## nthresh ==0
  set.seed(123)
  innov_1 <-  rnorm(200)
  sim_nth0 <- setar.gen(B=0.5, lag=1, nthresh=0, 
                        include ="none",
                        starting= 0.4,
                        innov=innov_1,
                        show.parMat = TRUE)$serie
  head(innov_1)
  head(sim_nth0)
  
  ar_1_noInc <- linear(log(lynx), m = 1, include = "none")
  ar_2_noInc <- linear(log(lynx), m = 2, include = "none")
  ar_1_const <- linear(log(lynx), m = 1, include = "const")
  ar_2_const <- linear(log(lynx), m = 2, include = "const")
  
  ar_1_noInc
  ar_1_noInc_check <- setar.boot(setarObject = ar_1_noInc, boot.scheme = "check")
  ar_2_noInc_check <- setar.boot(setarObject = ar_2_noInc, boot.scheme = "check")
  ar_1_const_check <- setar.boot(setarObject = ar_1_const, boot.scheme = "check")
  ar_2_const_check <- setar.boot(setarObject = ar_2_const, boot.scheme = "check", show.parMat = TRUE)
  
  all.equal(ar_1_noInc_check$serie, as.numeric(log(lynx)))
  all.equal(ar_2_noInc_check$serie, as.numeric(log(lynx)))
  all.equal(ar_1_const_check$serie, as.numeric(log(lynx)))
  all.equal(ar_2_const_check$serie, as.numeric(log(lynx)))
  
  ## nthresh ==1
  Bvals <- c(2.9,-0.4,-0.1, 2, 0.2,0.3)
  sim_new <- setar.gen(B=Bvals,lag=2, nthresh=1, Thresh=2, starting=c(2.8,2.2),
                       innov=rnorm(200), show.parMat = TRUE)$serie
  head(sim_new)
  set_1 <- setar(sim_new, m = 2)
  set_1_const_check <- setar.boot(setarObject =  set_1, boot.scheme = "check")$serie
  all.equal(set_1_const_check, sim_new)
  
  setar.sim(B=Bvals, lag=2, nthresh=1, Thresh=2)
}

if(FALSE){
  library(tsDyn)
  environment(setar.sim)<-environment(star)
  
  ##Simulation of a TAR with 1 threshold
  Bvals <- c(2.9,-0.4,-0.1,-1.5, 0.2,0.3)
  sim<-setar.sim(B=Bvals,lag=2, type="simul", nthresh=1, Thresh=2, starting=c(2.8,2.2))$serie
  mean(ifelse(sim>2,1,0))	#approximation of values over the threshold
  
  #check the result
  selectSETAR(sim, m=2, criterion="SSR")
  selectSETAR(sim, m=2, th=list(around=2, ngrid=20))
  
  
  ##Bootstrap a TAR with two threshold (three regimes)
  sun<-(sqrt(sunspot.year+1)-1)*2
  setar.sim(data=sun,nthresh=2, type="boot", Thresh=c(6,9))$serie
  
  ##Check the bootstrap
  checkBoot<-setar.sim(data=sun,nthresh=0, type="check", Thresh=6.14)$serie
  cbind(checkBoot,sun)
  #prob with the digits!
  
  ###linear object
  lin<-linear(sun, m=1)
  checkBootL<-setar.sim(setarObject=lin, type="check")$serie
  cbind(checkBootL,sun)
  linear(checkBootL, m=1)
  ###setar object
  setarSun<-setar(sun, m=2, nthresh=1)
  checkBoot2<-setar.sim(setarObject=setarSun, type="check")$serie
  cbind(checkBoot2,sun)

  #does not work

  setarSun<-setar(sun, m=3, nthresh=2)
  checkBoot3<-setar.sim(setarObject=setarSun, type="check")$serie
  cbind(checkBoot3,sun)
  #ndig approach: works with m=2, m=3, m=4
  #no ndig approach: output has then more digits than input

}
