#' @importFrom vars irf
#' @export
vars::irf

#' Impulse response function
#' 
#' Use the \code{fevd} function from package \pkg{vars} to tompute the impulse
#' response coefficients of a VAR(p) (or transformed VECM to VAR(p)) for
#' \code{n.ahead} steps.
#' 
#' The function converts the VAR or VECM computed by package tsDyn into an
#' object of class \sQuote{\code{vec2var}}, on which then the
#' \code{\link[vars]{irf}} method is applied. For details, see the relevant
#' package.
#' 
#' @param x Object of class \sQuote{\code{VAR}}; generated by
#' \command{lineVar()}, or object of class \sQuote{\code{VECM}}; generated
#' by\command{VECM()}.
#' @param impulse A character vector of the impulses, default is all variables.
#' @param response A character vector of the responses, default is all
#' variables.
#' @param n.ahead Integer specifying the steps.
#' @param ortho Logical, if \code{TRUE} (the default) the orthogonalised
#' impulse response coefficients are computed (only for objects of class
#' \sQuote{\code{varest}}).
#' @param cumulative Logical, if \code{TRUE} the cumulated impulse response
#' coefficients are computed. The default value is false.
#' @param boot Logical, if \code{TRUE} (the default) bootstrapped error bands
#' for the imuplse response coefficients are computed.
#' @param ci Numeric, the confidence interval for the bootstrapped errors
#' bands.
#' @param runs An integer, specifying the runs for the bootstrap.
#' @param seed An integer, specifying the seed for the \code{rng} of the
#' bootstrap.
#' @param ... Currently not used.
#' @return A list of class \sQuote{\code{varirf}} with the following elements
#' is returned:\cr
#' 
#' \item{irf}{A list with matrices for each of the impulse variables containing
#' the impulse response coefficients.} \item{Lower}{If \code{boot = TRUE}, a
#' list with matrices for each of the impulse variables containing the lower
#' bands.} \item{Upper}{If \code{boot = TRUE}, a list with matrices for each of
#' the impulse variables containing the upper bands.} \item{response}{Character
#' vector holding the names of the response variables.}
#' \item{impulse}{Character vector holding the names of the impulse variables.}
#' \item{ortho}{Logical, if \code{TRUE}, orthogonalised impulse reponses have
#' been computed.} \item{cumulative}{Logical, if \code{TRUE}, cumulated impulse
#' reponses have been computed.} \item{runs}{An integer, specifying the number
#' of bootstrap runs.} \item{ci}{Numeric, defining the confidence level.}
#' \item{boot}{Logical, if \code{TRUE} bootstrapped error bands have been
#' computed.} \item{model}{Character, containing \sQuote{\code{class(x)}}.}
#' @author Bernhard Pfaff
#' @seealso \code{\link{plot}} for the plot method. \code{\link{lineVar}},
#' \code{\link{VECM}} for the models.
#' @references Efron, B. and R. J. Tibshirani (1993), \emph{An Introduction to
#' the Bootstrap}, Chapman \& Hall, New York.
#' 
#' Hamilton, J. (1994), \emph{Time Series Analysis}, Princeton University
#' Press, Princeton.
#' 
#' Lutkepohl, H. (2006), \emph{New Introduction to Multiple Time Series
#' Analysis}, Springer, New York.
#' @keywords regression
#' @examples
#' 
#' data(barry)
#' 
#' ## For VAR
#' mod_var <- lineVar(barry, lag = 2)
#' irf(mod_var, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
#' FALSE)
#' 
#' ## For VECM
#' mod_VECM <- VECM(barry, lag = 2, estim="ML", r=2)
#' irf(mod_VECM, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
#' FALSE)
#' 

#' @importFrom vars irf
#' @export
irf.nlVar <- function(x, impulse=NULL, response=NULL, n.ahead=10, ortho=TRUE, cumulative=FALSE, boot=TRUE, ci=0.95, runs=100, seed=NULL, ...){
  model <- attr(x, "model")
  if(model=="VECM"){
    LRinc <- x$model.specific$LRinclude
    inc <- x$include
    if(LRinc=="both"|inc=="none"&LRinc=="none") stop("Sorry, irf() is not available for this specification of deterministic terms.")
  }
  irf(vec2var.tsDyn(x), impulse=impulse, response=response, n.ahead = n.ahead, ortho=ortho, cumulative=cumulative, boot=boot, ci=ci, runs=runs, seed=seed, ...)
}

### new way
get_series <- function(x) {
  if(inherits(x ,"nlVar")) {
    res <- colnames(x$model)[seq_len(x$k)]
  }
  res
}

#' @importFrom stats df.residual

irf_1.VAR <-  function(x, n.ahead=10, cumulative=FALSE, ortho =FALSE, regime = "all",  ...) {
  irf_1.nlVar(x, n.ahead = n.ahead,
              cumulative = cumulative,
              regime = regime,
              ortho = ortho, ...)

}

irf_1.TVAR <-  function(x, n.ahead=10, cumulative=FALSE, ortho =FALSE,  
                        regime = c("all", "L", "M", "H"), ...) {
  irf_1.nlVar(x, n.ahead = n.ahead, 
              cumulative = cumulative, 
              regime = regime, 
              ortho = ortho, ...)
  
}

irf_1.nlVar <-  function(x, n.ahead=10, cumulative=FALSE, regime = c("all", "L", "M", "H"), ortho =FALSE,  ...) {
  regime <-  match.arg(regime)
  series <- get_series(x)
  
  ##
  lag <-  x$lag
  k <-  x$k
  thDelay <-  x$thDelay
  nthresh <-  x$model.specific$nthresh

  coefs <- coef(x, regime = regime)

  ## 
  start <-  matrix(0, nrow= lag, ncol = k)
  innovs <-  matrix(0, nrow= n.ahead +1, ncol = k)
  
  if(any(grepl("Intercept|Trend", colnames(coefs)))) coefs <-  coefs[,-grep("Intercept|Trend", colnames(coefs))]
  init_vals_M <- diag(k)
  
  ## orthogonoalise
  if(ortho) {
    sigma.u <- crossprod(residuals(x)) / df.residual(x)
    P <- t(chol(sigma.u))
    init_vals_M <- init_vals_M %*% P
  } 

  ## shock first
  gen_1 <- function(k) {
    innov_k <- innovs
    innov_k[1, ] <-  init_vals_M[, k]
    out <- VAR.gen(B = coefs, n=n.ahead + 1, lag=lag, include = "none",  
                    starting = start, 
                    innov = innov_k, 
                    returnStarting = FALSE)
    colnames(out) <- series
    out
  }
  res_M <- lapply(seq_len(k), gen_1 )
  names(res_M) <- series
  
  if(cumulative) stop("TODO") #res <-  apply(res, 2, cumsum)
  
  ### results
  res_df <- as.data.frame(do.call("rbind", res_M))
  res_df$impulse <-  rep(names(res_M), each = n.ahead +1)
  res_df
}

## small function for internal checks
irf_1_check <-  function(x) {
  res <-  list()
  res$irf <-  split(x[, -ncol(x)], x$impulse)
  to_mat <-  function(x){
    x2 <- as.matrix(x)
    rownames(x2) <- NULL
    x2
  }
  res$irf <- lapply(res$irf, to_mat)
  res$boot <- FALSE
  class(res) <- "varirf"
  res
}


## #' @rdname irf.nlVar
### #' @export
# irf.VAR <-  function(x, impulse=NULL, response=NULL, n.ahead=10, ortho=TRUE, cumulative=FALSE, 
#                      boot=TRUE, ci=0.95, runs=100, seed=NULL, ...) {
#   irf_any(x=x, n.ahead = n.ahead, cumulative = cumulative, 
#           boot = boot, ci = ci, runs = runs, seed = seed, ...)
# }

if(FALSE){
  library(tsDyn)
  library(tidyverse)
  library(devtools)
  load_all()
  
  ## vars
  library(vars)
  data(Canada)
  var_vars_l1 <- VAR(Canada, p = 1, type = "const")
  var_vars_l4 <- VAR(Canada, p = 4, type = "const")
  irf_l1_vars <- irf(var_vars_l1, runs = 10, ortho = FALSE)
  irf_l1_vars_ortho <- irf(var_vars_l1, boot = FALSE, ortho = TRUE)
  irf_l4_vars <- irf(var_vars_l4, boot = FALSE, ortho = FALSE)
  irf_l4_vars_ortho <- irf(var_vars_l4, boot = FALSE, ortho = TRUE)
  lapply(irf_l1_vars$irf, head, 2)
  
  # tsDyn
  library(tsDyn)
  # x <- lineVar(Canada, lag=4)
  var_tsD_l1 <- lineVar(Canada, lag=1)
  var_tsD_l4 <- lineVar(Canada, lag=4)
  coef(var_tsD_l1)[1,]
  coef(var_vars_l1)$e[, 1]
  
  ## deg freedom
  all.equal(var_vars_l1$obs,   var_tsD_l1$t)
  df.residual(var_tsD_l1)
  
  ##
  irf_l1_tsD <- irf_1(var_tsD_l1) %>% irf_1_check
  irf_l4_tsD <- irf_1(var_tsD_l4) %>% irf_1_check
  irf_l4_tsD$irf
  irf_l1_tsD
  # plot(irf_l1_tsD)
  
  ## irf tsD ortho
  irf_l1_tsD_ortho <- irf_1(x=var_tsD_l1, ortho = TRUE) %>% irf_1_check
  irf_l4_tsD_ortho <- irf_1(var_tsD_l4, ortho = TRUE) %>% irf_1_check
  
  
  ## compare
  all.equal(irf_l1_vars$irf, irf_l1_tsD$irf)
  all.equal(irf_l1_vars_ortho$irf, irf_l1_tsD_ortho$irf)
  
  all.equal(irf_l4_vars$irf, irf_l4_tsD$irf)
  all.equal(irf_l4_vars_ortho$irf, irf_l4_tsD_ortho$irf)
  
  
  ##
  a <- irf_1(x=var_tsD_l1, ortho = TRUE)
  
  #### Now irf_any
  irf_any_VAR <- irf_any(x=var_tsD_l1, boot = TRUE, ortho = FALSE)
  irf_any_VAR <- irf_any(x=var_tsD_l1, boot = TRUE, ortho = FALSE)
  irf_any_VAR
  
  ##
  r1 <- irf_l1_vars$irf[[1]]
  all.equal(irf_l1_vars$irf, irf_any_VAR$irf)
  irf_any_VAR$irf[[1]]
  irf_any_VAR$Lower[[1]]
  all.equal(irf_l1_vars$Lower[[1]], irf_any_VAR$Lower[[1]])
}