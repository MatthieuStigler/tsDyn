#' @importFrom vars irf
#' @export
vars::irf

#' Impulse response function
#' 
#' Use the \code{fevd} function from package \pkg{vars} to tompute the impulse
#' response coefficients of a VAR(p) (or transformed VECM to VAR(p)) for
#' \code{n.ahead} steps.
#' 
#' The function converts the VAR or VECM computed by package tsDyn into an
#' object of class \sQuote{\code{vec2var}}, on which then the
#' \code{\link[vars]{irf}} method is applied. For details, see the relevant
#' package.
#' 
#' @param x Object of class \sQuote{\code{VAR}}; generated by
#' \command{lineVar()}, or object of class \sQuote{\code{VECM}}; generated
#' by\command{VECM()}.
#' @param impulse A character vector of the impulses, default is all variables.
#' @param response A character vector of the responses, default is all
#' variables.
#' @param n.ahead Integer specifying the steps.
#' @param ortho Logical, if \code{TRUE} (the default) the orthogonalised
#' impulse response coefficients are computed (only for objects of class
#' \sQuote{\code{varest}}).
#' @param cumulative Logical, if \code{TRUE} the cumulated impulse response
#' coefficients are computed. The default value is false.
#' @param boot Logical, if \code{TRUE} (the default) bootstrapped error bands
#' for the imuplse response coefficients are computed.
#' @param ci Numeric, the confidence interval for the bootstrapped errors
#' bands.
#' @param runs An integer, specifying the runs for the bootstrap.
#' @param seed An integer, specifying the seed for the \code{rng} of the
#' bootstrap.
#' @param ... Currently not used.
#' @return A list of class \sQuote{\code{varirf}} with the following elements
#' is returned:\cr
#' 
#' \item{irf}{A list with matrices for each of the impulse variables containing
#' the impulse response coefficients.} \item{Lower}{If \code{boot = TRUE}, a
#' list with matrices for each of the impulse variables containing the lower
#' bands.} \item{Upper}{If \code{boot = TRUE}, a list with matrices for each of
#' the impulse variables containing the upper bands.} \item{response}{Character
#' vector holding the names of the response variables.}
#' \item{impulse}{Character vector holding the names of the impulse variables.}
#' \item{ortho}{Logical, if \code{TRUE}, orthogonalised impulse reponses have
#' been computed.} \item{cumulative}{Logical, if \code{TRUE}, cumulated impulse
#' reponses have been computed.} \item{runs}{An integer, specifying the number
#' of bootstrap runs.} \item{ci}{Numeric, defining the confidence level.}
#' \item{boot}{Logical, if \code{TRUE} bootstrapped error bands have been
#' computed.} \item{model}{Character, containing \sQuote{\code{class(x)}}.}
#' @author Bernhard Pfaff
#' @seealso \code{\link{plot}} for the plot method. \code{\link{lineVar}},
#' \code{\link{VECM}} for the models.
#' @references Efron, B. and R. J. Tibshirani (1993), \emph{An Introduction to
#' the Bootstrap}, Chapman \& Hall, New York.
#' 
#' Hamilton, J. (1994), \emph{Time Series Analysis}, Princeton University
#' Press, Princeton.
#' 
#' Lutkepohl, H. (2006), \emph{New Introduction to Multiple Time Series
#' Analysis}, Springer, New York.
#' @keywords regression
#' @examples
#' 
#' data(barry)
#' 
#' ## For VAR
#' mod_var <- lineVar(barry, lag = 2)
#' irf(mod_var, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
#' FALSE)
#' 
#' ## For VECM
#' mod_VECM <- VECM(barry, lag = 2, estim="ML", r=2)
#' irf(mod_VECM, impulse = "dolcan", response = c("dolcan", "cpiUSA", "cpiCAN"), boot =
#' FALSE)
#' 

#' @importFrom vars irf
#' @export
irf.nlVar <- function(x, impulse=NULL, response=NULL, n.ahead=10, ortho=TRUE, cumulative=FALSE, boot=TRUE, ci=0.95, runs=100, seed=NULL, ...){
  model <- attr(x, "model")
  if(model=="VECM"){
    LRinc <- x$model.specific$LRinclude
    inc <- x$include
    if(LRinc=="both"|inc=="none"&LRinc=="none") stop("Sorry, irf() is not available for this specification of deterministic terms.")
  }
  irf(vec2var.tsDyn(x), impulse=impulse, response=response, n.ahead = n.ahead, ortho=ortho, cumulative=cumulative, boot=boot, ci=ci, runs=runs, seed=seed, ...)
}

### new way
get_series <- function(x) {
  if(inherits(x ,"nlVar")) {
    res <- colnames(x$model)[seq_len(x$k)]
  }
  res
}

irf_1.VAR <-  function(x, n.ahead=10, cumulative=FALSE, regime = c("L", "M", "H"), ...) {
  regime <-  match.arg(regime)
  series <- get_series(x)
  
  ##
  lag <-  x$lag
  k <-  x$k
  thDelay <-  x$thDelay
  nthresh <-  x$model.specific$nthresh

  coefs <- coef(x)

  ## 
  start <-  matrix(0, nrow= lag, ncol = k)
  innovs <-  matrix(0, nrow= n.ahead +1, ncol = k)
  
  if(any(grepl("Intercept|trend", colnames(coefs)))) coefs <-  coefs[,-grep("Intercept|trend", colnames(coefs))]

  ## shock first
  gen_1 <- function(k) {
    innov_k <- innovs
    innov_k[1, k] <-  1
    out <- VAR.gen(B = coefs, n=n.ahead + 1, lag=lag, include = "none",  
                    starting = start, 
                    innov = innov_k, 
                    returnStarting = FALSE)
    colnames(out) <- series
    out
  }
  res_M <- lapply(seq_len(k), gen_1 )
  names(res_M) <- series
  
  if(cumulative) res <-  apply(res, 2, cumsum)
  
  ### results
  res <- list()
  res$irf <- res_M
  res$boot <- FALSE
  class(res) <- "varirf"
  res
}


if(FALSE){
  
  VAR.gen <- tsDyn:::VAR.gen
  irf_1.VAR <- tsDyn:::irf_1.VAR
  
  
  ## vars
  library(vars)
  data(Canada)
  var.2c <- VAR(Canada, p = 1, type = "const")
  irf_vars <- irf(var.2c, boot = FALSE, ortho = FALSE)
  lapply(irf_vars$irf, head, 2)
  
  # tsDyn
  library(tsDyn)
  x <- lineVar(Canada, lag=1)
  coef(x)[1,]
  coef(var.2c)$e[, 1]
  irf_tsD <- irf_1.VAR(x)
  irf_tsD$irf
  irf_tsD
  plot(irf_tsD)
  
  ## compare
  all.equal(irf_vars$irf, irf_tsD$irf)
  
}